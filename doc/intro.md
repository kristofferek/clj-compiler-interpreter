# Introduction to project

### File structure
```
+-- src/
| +-- project/
| | +-- addMulCompiler clj
| | +-- addMulInterpreter clj
| | +-- addSubCompiler clj
| | +-- addSubInterpreter clj
| | +-- arithInterpreter clj
| | +-- constCompiler clj
| | +-- constInterpreter clj
| | +-- core clj
| | +-- lang Compiler clj
| | +-- lang Interpreter clj
| | +-- lang Compiler clj
| | +-- lang Interpreter clj
+-- doc/
+-- project clj
```
### Languages
* ConstMod
* AddSubMod
* AddMultMod
* ArithMod
* ArithExpMod
* Lang0Mod
* Lang1Mod

### Int -> Long
In order for us to handle big numbers we converted both the interpreter and the compiler to work with the primitive type Long instead of the initial type int.
This meant we now parse all numbers in the _AST_ as Longs, changing the method signature of the generated bytecode as well as the operation bytecodes _(Opcodes/IADD_ -> _Opcodes/LADD_).
Another thing we had to modify due to this was the handling of arguments since they were coded as int's and not as long's. Int's only take up one block in memory and long take up 2 blocks. We solved this by adding another increment to where the variable indexes (in local memory) are calculated.

### Modulo
The methods for handling the modulo operation is located in _constCompiler.clj_ as well as in _constInterpreter.clj_.
In our language, the modulo operand is represented with a "%".
Since the the language should be able to handle very big numbers(more than what long can represent) we choose to create
a function called `mod-exp` to convert the numbers as _biginteger_ and perform modulo on each number separately before we parse the full expresison.
**Interpreter**
`mod-parser`, `mod-interpreter`, and `mod-eval` are the three methods responsible for interpreting the "%".
The parser will transform it to the keyword :mod and it then evaluated by using clojure's _mod_ function.
**Compiler**
We use the _Opcodes/LREM_ to perform the remainder, which it works like modulo for positive numbers.
For the negatives we create a function called `rem-sign` which transform a negative result to the correct positive one.

### Exponentials
We use a java method called `modPow` to calculate modulo of big numbers which we use before passing the expression to the parser.
In the case of variable name management in the exponential expressions, we didn't succeed to implement it. One possible way to solve this is
defining a function in bytecode for exponential calculus.
